#include  <iostream>		//для использования потоков ввода/вывода
#include  <intrin.h> //для NOP

int nTwin = 1;			//глобальная переменная
namespace TwinSpace { int nTwin = 2; }	//переменная объявлена в
//пространстве имен - TwinSpace

#define	  stop __nop();	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{

	//**********************************************************
	   //Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	   //следите за значениями переменных и интерпретируйте результат (помните, что 
	   //количество байт, отводимых под int, системо-зависимо).
	   //Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	   //данных, а также на внутреннее представление отрицательных целых чисел.


	char cByte = 'A';    // переменной cByte присваивается символ 'A'
	cByte = 0x42;        // присваивается символ 'B' с шестнадцатеричным кодом 42
	cByte = 66;          // присваивается символ 'B' с кодом ASCII 66
	cByte = -1;          // присваивается символ 'я'

	unsigned char ucByte = 0x41; // переменной ucByte присваивается символ 'A' с шестнадцатеричным кодом 41
	ucByte = 'B';         // присваивается символ 'B'
	ucByte = -1;          // ASCII код изменяется на 255, присваивается символ 'я'

	int iInt = 0xffffffff;   // переменной iInt присваивается -1, т.к. значение превосходит максимальное допустимое

	unsigned int uiInt = 0xffffffff;    // присваивается значение 4294967295

	float fFloat = 1.f;       // переменной присваивается значение 1
	double dDouble = 1.;      // присваивается значение 1 (больше нулей после точки)

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789;   // присваивается округлённое значение 0.12345678901234568 
	float  f = 0.1234567890123456789123456789;   // присваивается округлённое значение 0.123456791
	// кол-во цифр после точки определяется типом данных

	d = 1.;                // присваивается значение 1 типа double
	d = 0.999999999999999999999999999999999;   // присваивается округлённое значение 1

	stop

		// В комментариях напишите результат, возвращаемый оператором sizeof для
		// переменной типа wchar_t (ее размер)
		wchar_t cw = L'Ф';
	size_t n = sizeof(cw);   // n = 2

	stop


		// **************************************************************
			//Задание 2a. Неявное приведение типов данных.
			//Объясните разницу результата при выполнении (1) и (2):
			//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

		iInt = 1;
	double dDouble1 = iInt / 3;		// (1)  dDouble1 = double(int(1/3)) = 0, (т.к. делим int на int, то получаем int)
	double dDouble2 = iInt / 3.;	// (2) dDouble2 = 0.33333333333333331 (т.к. делим int на float, то получаем float)


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3;			// (1) (dDouble = (fFloat = (iInt = (sShort = (cByte = 3.3 / 3)))));
	// сначала значение присваивается типу char, поэтому оно сразу округляется до 1.
	
	cByte = sShort = iInt = fFloat = dDouble = 3.3 / 3;			// (2) (cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3)))));
	// сначала значение присваивается типу double
	// предупреждение - воозможная потеря данных - связано с присваиванием одного типа данных другому

	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt = 257;
	cByte = iInt; // cByte = 1, т.к. 257 выходит за пределы допустимых значений char

	unsigned char cN1 = 255, cN2 = 2, cSum;
	cSum = cN1 + cN2; // cSum = char(257) = 1

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1 + cN2; // iSum = 255 + 2 = 257, т.к. оно входит в диапазон допустимых значений int

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1 = 0xff, c2 = 2;
	unsigned char uc1 = 0xff, uc2 = 2;
	int iSum1 = c1 + c2;   //(1) iSum1 = 1
	int iSum2 = uc1 + uc2; //(2) iSum2 = 257
	// char и unsigned char имеют разные допустимые max положительные значения
	stop


		// ***********************************************************
			//Задание 2b. Явное приведение типов данных.
			//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
			// Напишите явно преобразования, которые неявно выполняет компилятор
		int nTmp = 100, nn = 3;
	dDouble = 3.3 + nTmp / nn; // (3)

	//Получите результат без потери точности с помощью оператора явного
	//приведения типа
	double dDouble3 = 3.3 + double(nTmp) / nn;		// (4)


	stop


	return 0;//код завершения приложения
}	// Конец функции main()

